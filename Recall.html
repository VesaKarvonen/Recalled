<!DOCTYPE html>
<html>
<head>
<title>Recall Library Reference</title>
<style>
pre {
border: 1px solid #e0e0e0;
border-radius: 3px;
padding: 5px;
line-height: 160%;
background: #f7f7f7;
font-family: "Lucida Console", Monaco, monospace;
font-size: 72%;
}
code {
border: 1px solid #e0e0e0;
border-radius: 3px;
padding: 2px;
background: #f7f7f7;
font-family: "Lucida Console", Monaco, monospace;
font-size: 72%;
}
div.nested {
padding-left: 1.5em;
}
a {
text-decoration: none;
font-weight: bold;
}
</style>
</head>
<body><table width="80%" align="center"><tr><td>
<h1>Recall Library Reference</h1>
<p>This document provides a reference manual for the Recall library and is generated from the library source code.</p>
<h2>Synopsis</h2>
<pre><b>namespace</b> <a id="dec:namespace Recall" href="#def:namespace Recall">Recall</a></pre>
<pre><b>type</b> <a id="dec:type Recall.Log" href="#def:type Recall.Log">Log</a>
</pre>
<pre><b>type</b> <a id="dec:type Recall.Update" href="#def:type Recall.Update">Update</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<pre><b>type</b> <a id="dec:type Recall.Logged" href="#def:type Recall.Logged">Logged</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<pre><b>type</b> <a id="dec:type Recall.WithLog" href="#def:type Recall.WithLog">WithLog</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>=</b> <a href="#def:type Recall.Log">Log</a> <b>-&gt;</b> Job<b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<pre><b>type</b> <a id="dec:type Recall.UpdateBuilder" href="#def:type Recall.UpdateBuilder">UpdateBuilder</a>  <b>=</b>
  <b>new</b><b>:</b> unit <b>-&gt;</b> <a href="#def:type Recall.UpdateBuilder">UpdateBuilder</a>
  <b>member</b> Delay<b>:</b> (unit <b>-&gt;</b> <a href="#def:type Recall.Update">Update</a><b>&lt;</b><i>'x</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Recall.Update">Update</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>member</b> Return<b>:</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Recall.Update">Update</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>member</b> ReturnFrom<b>:</b>  <a href="#def:type Recall.Update">Update</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Recall.Update">Update</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>member</b> ReturnFrom<b>:</b>     Job<b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Recall.Update">Update</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>member</b> Bind<b>:</b>         <a href="#def:type Recall.Update">Update</a><b>&lt;</b><i>'x</i><b>&gt;</b>  <b>*</b> (<i>'x</i> <b>-&gt;</b> <a href="#def:type Recall.Update">Update</a><b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Recall.Update">Update</a><b>&lt;</b><i>'y</i><b>&gt;</b>
  <b>member</b> Bind<b>:</b>         <a href="#def:type Recall.Logged">Logged</a><b>&lt;</b><i>'x</i><b>&gt;</b>  <b>*</b> (<i>'x</i> <b>-&gt;</b> <a href="#def:type Recall.Update">Update</a><b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Recall.Update">Update</a><b>&lt;</b><i>'y</i><b>&gt;</b>
  <b>member</b> Bind<b>:</b> <a href="#def:type Recall.WithLog">WithLog</a><b>&lt;</b><a href="#def:type Recall.Logged">Logged</a><b>&lt;</b><i>'x</i><b>&gt;&gt;</b> <b>*</b> (<i>'x</i> <b>-&gt;</b> <a href="#def:type Recall.Update">Update</a><b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Recall.Update">Update</a><b>&lt;</b><i>'y</i><b>&gt;</b>
  <b>member</b> Bind<b>:</b>            Job<b>&lt;</b><i>'x</i><b>&gt;</b>  <b>*</b> (<i>'x</i> <b>-&gt;</b> <a href="#def:type Recall.Update">Update</a><b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Recall.Update">Update</a><b>&lt;</b><i>'y</i><b>&gt;</b>
</pre>
<pre><b>[&lt;</b>Class<b>&gt;]</b> 
<b>type</b> <a id="dec:type Recall.LoggedBuilder" href="#def:type Recall.LoggedBuilder">LoggedBuilder</a>  <b>=</b>
  inherit <a href="#def:type Recall.UpdateBuilder">UpdateBuilder</a>
  <b>member</b> Run<b>:</b> <a href="#def:type Recall.Update">Update</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Recall.WithLog">WithLog</a><b>&lt;</b><a href="#def:type Recall.Logged">Logged</a><b>&lt;</b><i>'x</i><b>&gt;&gt;</b>
</pre>
<pre><b>type</b> <a id="dec:type Recall.WithLogBuilder" href="#def:type Recall.WithLogBuilder">WithLogBuilder</a>  <b>=</b>
  <b>new</b><b>:</b> unit <b>-&gt;</b> <a href="#def:type Recall.WithLogBuilder">WithLogBuilder</a>
  <b>member</b> Delay<b>:</b> (unit <b>-&gt;</b> <a href="#def:type Recall.WithLog">WithLog</a><b>&lt;</b><i>'x</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Recall.WithLog">WithLog</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>member</b> Return<b>:</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Recall.WithLog">WithLog</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>member</b> ReturnFrom<b>:</b> <a href="#def:type Recall.WithLog">WithLog</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Recall.WithLog">WithLog</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>member</b> ReturnFrom<b>:</b>     Job<b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Recall.WithLog">WithLog</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>member</b> Bind<b>:</b> <a href="#def:type Recall.WithLog">WithLog</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>*</b> (<i>'x</i> <b>-&gt;</b> <a href="#def:type Recall.WithLog">WithLog</a><b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Recall.WithLog">WithLog</a><b>&lt;</b><i>'y</i><b>&gt;</b>
  <b>member</b> Bind<b>:</b>     Job<b>&lt;</b><i>'x</i><b>&gt;</b> <b>*</b> (<i>'x</i> <b>-&gt;</b> <a href="#def:type Recall.WithLog">WithLog</a><b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Recall.WithLog">WithLog</a><b>&lt;</b><i>'y</i><b>&gt;</b>
  <b>member</b> TryFinally<b>:</b> <a href="#def:type Recall.WithLog">WithLog</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>*</b> (unit <b>-&gt;</b> unit) <b>-&gt;</b> <a href="#def:type Recall.WithLog">WithLog</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>member</b> TryWith<b>:</b> <a href="#def:type Recall.WithLog">WithLog</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>*</b> (exn <b>-&gt;</b> <a href="#def:type Recall.WithLog">WithLog</a><b>&lt;</b><i>'x</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Recall.WithLog">WithLog</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>member</b> Using<b>:</b> <i>'x</i> <b>*</b> (<i>'x</i> <b>-&gt;</b> <a href="#def:type Recall.WithLog">WithLog</a><b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Recall.WithLog">WithLog</a><b>&lt;</b><i>'y</i><b>&gt;</b> <b>when</b> <i>'x</i> <b>:&gt;</b> IDisposable
  <b>member</b> For<b>:</b> seq<b>&lt;</b><i>'x</i><b>&gt;</b> <b>*</b> (<i>'x</i> <b>-&gt;</b> <a href="#def:type Recall.WithLog">WithLog</a><b>&lt;</b>unit<b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Recall.WithLog">WithLog</a><b>&lt;</b>unit<b>&gt;</b>
  <b>member</b> While<b>:</b> (unit <b>-&gt;</b> bool) <b>*</b> <a href="#def:type Recall.WithLog">WithLog</a><b>&lt;</b>unit<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Recall.WithLog">WithLog</a><b>&lt;</b>unit<b>&gt;</b>
  <b>member</b> Zero<b>:</b> unit <b>-&gt;</b> <a href="#def:type Recall.WithLog">WithLog</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<pre><b>[&lt;</b>Class<b>&gt;]</b> 
<b>type</b> <a id="dec:type Recall.RunWithLogBuilder" href="#def:type Recall.RunWithLogBuilder">RunWithLogBuilder</a>  <b>=</b>
  inherit <a href="#def:type Recall.WithLogBuilder">WithLogBuilder</a>
  <b>member</b> Run<b>:</b> <a href="#def:type Recall.WithLog">WithLog</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> Job<b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<pre><b>[&lt;</b>AutoOpen<b>&gt;]</b>
<b>module</b> <a id="dec:module Recall.Recall" href="#def:module Recall.Recall">Recall</a>  <b>=</b>
  <b>val</b> <a id="dec:val Recall.Recall.recall" href="#def:val Recall.Recall.recall">recall</a><b>:</b> logDir<b>:</b> string <b>-&gt;</b> <a href="#def:type Recall.RunWithLogBuilder">RunWithLogBuilder</a>
  <b>val</b> <a id="dec:val Recall.Recall.logged" href="#def:val Recall.Recall.logged">logged</a><b>:</b> <a href="#def:type Recall.WithLogBuilder">WithLogBuilder</a>
  <b>val</b> <a id="dec:val Recall.Recall.log" href="#def:val Recall.Recall.log">log</a><b>:</b> id<b>:</b> string <b>-&gt;</b> <a href="#def:type Recall.LoggedBuilder">LoggedBuilder</a>
  <b>val</b> <a id="dec:val Recall.Recall.read" href="#def:val Recall.Recall.read">read</a><b>:</b> <a href="#def:type Recall.Logged">Logged</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> Alt<b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Recall.Recall.getCancelAlt" href="#def:val Recall.Recall.getCancelAlt">getCancelAlt</a><b>:</b> <a href="#def:type Recall.Update">Update</a><b>&lt;</b>Alt<b>&lt;</b>unit<b>&gt;&gt;</b>
</pre>
<h2>Description</h2>
<pre><b>namespace</b> <a id="def:namespace Recall" href="#dec:namespace Recall">Recall</a>
</pre>
<div class="nested"><p> Recall is a library for defining persistent, incremental, parallel computations such as build systems.  The main goals for Recall are to make it convenient to define such computations and to be able to scale such computations.</p><p> The central concept of Recall is that of a logged computation, represented by the <code><a href="#def:type Recall.Logged">Logged</a><b>&lt;</b><i>'x</i><b>&gt;</b></code> type constructor.  A logged computation is defined and executed in such a manner that after it has been run to completion, the computation can be recreated, possibly in a separate run of the program, and its result can be recovered without actually running the recreated computation to completion, assuming Recall finds nothing that has changed that could change the result of the computation.</p><p> A correctly defined logged computation is recomputed by Recall if it needs to be recomputed, because its result may have changed.  Recall makes it easy for the programmer to write correct logged computations, but does not strictly enforce correctness.  Strictly enforcing correctness is essentially impossible to do in a impure language in a convenient manner, because it precludes the use of built-in lambda expressions.  Therefore Recall chooses convenience over cumbersomeness.  To define a correct logged computation, the programmer simply needs to make sure that any input that may change the output of a computation is essentially seen by Recall.</p><p> Logged computations are defined and executed using lightweight threads, called jobs, provided by the Hopac library.  This directly allows logged computations to scale to multiple cores to exploit parallelism.  The use of lightweight threads also allows a logged computation to perform long latency operations, e.g. to perform distributed operations over a network of machines or to perform other forms of asynchronous IO, while allowing full use of the cores of the local machine to process other computations.<pre><b>type</b> <a id="def:type Recall.Log" href="#dec:type Recall.Log">Log</a>
</pre>
<div class="nested"><p> Represents a persistent storage.</div>
<pre><b>type</b> <a id="def:type Recall.Update" href="#dec:type Recall.Update">Update</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Represents a single primitive step or a sequence of steps of a possibly logged computation.</div>
<pre><b>type</b> <a id="def:type Recall.Logged" href="#dec:type Recall.Logged">Logged</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Represents a logged computation.</p><p> During a logged computation, binding the value of another logged computation makes the current logged computation dependent on the result of the bound logged computation.  This way Recall learns about the input that may change the output of a computation.</div>
<pre><b>type</b> <a id="def:type Recall.WithLog" href="#dec:type Recall.WithLog">WithLog</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>=</b> <a href="#def:type Recall.Log">Log</a> <b>-&gt;</b> Job<b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Represents a parallel computation with a log.</div>
<pre><b>type</b> <a id="def:type Recall.UpdateBuilder" href="#dec:type Recall.UpdateBuilder">UpdateBuilder</a>  <b>=</b>
</pre>
<div class="nested"><p> Builder for steppable computations.</p><p> Note that steppable computations allow only a limited set of computational patterns, because a steppable computation is not guaranteed to be run to completion.  Specifically, while a single step of a computation is guaranteed to be run to completion after it has been started, a sequence of steps is not guaranteed to be run to completion.  Because of this, constructs such as <code><b>use</b></code> cannot be given meaningful semantics.  However, within a single step, even one defined as a job, such constructs can be used.</div>
<pre><b>[&lt;</b>Class<b>&gt;]</b> 
<b>type</b> <a id="def:type Recall.LoggedBuilder" href="#dec:type Recall.LoggedBuilder">LoggedBuilder</a>  <b>=</b>
</pre>
<div class="nested"><p> Builder for logged computations.  A logged computation is essentially a steppable computation, whose steps are logged, while it is being executed.</div>
<pre><b>type</b> <a id="def:type Recall.WithLogBuilder" href="#dec:type Recall.WithLogBuilder">WithLogBuilder</a>  <b>=</b>
</pre>
<div class="nested"><p> Builder for parallel computations with a log.  A computation with a log is executed in a context with a log for logging individual logged computations.</div>
<pre><b>[&lt;</b>Class<b>&gt;]</b> 
<b>type</b> <a id="def:type Recall.RunWithLogBuilder" href="#dec:type Recall.RunWithLogBuilder">RunWithLogBuilder</a>  <b>=</b>
</pre>
<div class="nested"><p> Builder for running a parallel computations with a log.</div>
<pre><b>[&lt;</b>AutoOpen<b>&gt;]</b>
<b>module</b> <a id="def:module Recall.Recall" href="#dec:module Recall.Recall">Recall</a>  <b>=</b>
</pre>
<div class="nested"><p> Operations for defining computations with Recall.<pre><b>val</b> <a id="def:val Recall.Recall.recall" href="#dec:val Recall.Recall.recall">recall</a><b>:</b> logDir<b>:</b> string <b>-&gt;</b> <a href="#def:type Recall.RunWithLogBuilder">RunWithLogBuilder</a>
</pre>
<div class="nested"><p> Creates a job that creates a new or reads an existing computation log stored in the specified directory, creates and runs the given update computation and then waits until all the logged computations have either finished successfully or some computations have failed and the rest have been canceled.  In case all computations finished successfully, the result value is produced.  Otherwise an exception is raised with details on the failed computations.</div>
<pre><b>val</b> <a id="def:val Recall.Recall.logged" href="#dec:val Recall.Recall.logged">logged</a><b>:</b> <a href="#def:type Recall.WithLogBuilder">WithLogBuilder</a>
</pre>
<div class="nested"><p> A builder for parallel computations with a log.</div>
<pre><b>val</b> <a id="def:val Recall.Recall.log" href="#dec:val Recall.Recall.log">log</a><b>:</b> id<b>:</b> string <b>-&gt;</b> <a href="#def:type Recall.LoggedBuilder">LoggedBuilder</a>
</pre>
<div class="nested"><p> Returns a builder for creating a new logged computation with the given identity, which must be unique.  The result of the computation is persisted to a computation log along with dependencies to other logged computations.</p><p> The first time a logged computations is created, it is always run to completion.  When a logged computation with the same identity is recreated it may or may not be run to completion.</p><p> In case the log indicates that the recreated computation has no dependencies to other logged computations then computation is run to completion every time it is recreated.  This makes it convenient to essentially create new primitive operations and is also quite logical as a computation that has no inputs must either be a constant or it must use some hidden effects to compute its output.</p><p> If, however, the log has a non empty sequence of dependencies to other logged computations, then the recreated computation is run to completion only if the sequence of dependencies changes or the result of any one of those logged computations has changed.  This works correctly as long as any input that may change the result of the computation are bound as other logged computations within the defined logged computation.</div>
<pre><b>val</b> <a id="def:val Recall.Recall.read" href="#dec:val Recall.Recall.read">read</a><b>:</b> <a href="#def:type Recall.Logged">Logged</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> Alt<b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Returns an operation for reading the result of a logged computation.</div>
<pre><b>val</b> <a id="def:val Recall.Recall.getCancelAlt" href="#dec:val Recall.Recall.getCancelAlt">getCancelAlt</a><b>:</b> <a href="#def:type Recall.Update">Update</a><b>&lt;</b>Alt<b>&lt;</b>unit<b>&gt;&gt;</b>
</pre>
<div class="nested"><p> Provides an alternative that becomes enabled if some computation within the whole logged computation has failed.  This allows long running computation steps to cancel themselves cleanly without having to wait until the completion of the step.</p><p> Note that Recall automatically cancels computations in case of failure. Explicit cancellation is unlikely to provide any benefits except in case of computations that perform long running embedded asynchronous operations.</div>
</div>
</div>
</td></tr></table></body>
</html>
