<!DOCTYPE html>
<html>
<head>
<title>Recalled Library Reference</title>
<style>
pre {
border: 1px solid #e0e0e0;
border-radius: 3px;
padding: 5px;
line-height: 160%;
background: #f7f7f7;
font-family: "Lucida Console", Monaco, monospace;
font-size: 72%;
}
code {
border: 1px solid #e0e0e0;
border-radius: 3px;
padding: 2px;
background: #f7f7f7;
font-family: "Lucida Console", Monaco, monospace;
font-size: 72%;
}
div.nested {
padding-left: 1.5em;
}
a {
text-decoration: none;
font-weight: bold;
}
</style>
</head>
<body><table width="80%" align="center"><tr><td>
<h1>Recalled Library Reference</h1>
<p>This document provides a reference manual for the Recalled library and is generated from the library source code.</p>
<h2>Synopsis</h2>
<pre><b>namespace</b> <a id="dec:namespace Recalled" href="#def:namespace Recalled">Recalled</a></pre>
<pre><b>[&lt;</b>AbstractClass<b>&gt;]</b> 
<b>type</b> <a id="dec:type Recalled.PU" href="#def:type Recalled.PU">PU</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>=</b>
  <b>new</b><b>:</b> unit <b>-&gt;</b> PU<b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>abstract</b> <a id="dec:abstract Recalled.PU.Size" href="#def:abstract Recalled.PU.Size">Size</a><b>:</b> <i>'x</i> <b>-&gt;</b> int
  <b>abstract</b> <a id="dec:abstract Recalled.PU.Dopickle" href="#def:abstract Recalled.PU.Dopickle">Dopickle</a><b>:</b> <i>'x</i> <b>*</b> nativeptr<b>&lt;</b>byte<b>&gt;</b> <b>-&gt;</b> unit
  <b>abstract</b> <a id="dec:abstract Recalled.PU.Unpickle" href="#def:abstract Recalled.PU.Unpickle">Unpickle</a><b>:</b> nativeptr<b>&lt;</b>byte<b>&gt;</b> <b>-&gt;</b> <i>'x</i>
</pre>
<pre><b>type</b> <a id="dec:type Recalled.OpenPU" href="#def:type Recalled.OpenPU">OpenPU</a><b>&lt;</b><i>'t</i><b>&gt;</b>
</pre>
<pre><b>type</b> <a id="dec:type Recalled.ProductPU" href="#def:type Recalled.ProductPU">ProductPU</a><b>&lt;</b><i>'e</i>, <i>'es</i>, <i>'t</i><b>&gt;</b>
</pre>
<pre><b>type</b> <a id="dec:type Recalled.UnionPU" href="#def:type Recalled.UnionPU">UnionPU</a><b>&lt;</b><i>'c</i>, <i>'cs</i>, <i>'t</i><b>&gt;</b>
</pre>
<pre><b>[&lt;</b>InferenceRules<b>&gt;]</b> 
<b>type</b> <a id="dec:type Recalled.PU" href="#def:type Recalled.PU">PU</a>  <b>=</b>
  <b>static</b> <b>member</b> <a id="dec:static member Recalled.PU.Get" href="#def:static member Recalled.PU.Get">Get</a><b>:</b> unit <b>-&gt;</b> PU<b>&lt;</b><i>'t</i><b>&gt;</b>
  <b>new</b><b>:</b> unit <b>-&gt;</b> PU
  <b>member</b> <a id="dec:member Recalled.PU.toPU" href="#def:member Recalled.PU.toPU">toPU</a><b>:</b> <a href="#def:type Recalled.OpenPU">OpenPU</a><b>&lt;</b><i>'t</i><b>&gt;</b> <b>-&gt;</b> PU<b>&lt;</b><i>'t</i><b>&gt;</b>
  <b>member</b> <a id="dec:member Recalled.PU.fix" href="#def:member Recalled.PU.fix">fix</a><b>:</b> unit <b>-&gt;</b> Rec<b>&lt;</b><a href="#def:type Recalled.OpenPU">OpenPU</a><b>&lt;</b><i>'t</i><b>&gt;&gt;</b>
  <b>member</b> <a id="dec:member Recalled.PU.unit" href="#def:member Recalled.PU.unit">unit</a><b>:</b> <a href="#def:type Recalled.OpenPU">OpenPU</a><b>&lt;</b>unit<b>&gt;</b>
  <b>member</b> <a id="dec:member Recalled.PU.bool" href="#def:member Recalled.PU.bool">bool</a><b>:</b> <a href="#def:type Recalled.OpenPU">OpenPU</a><b>&lt;</b><a href="#def:member Recalled.PU.bool">bool</a><b>&gt;</b>
  <b>member</b> <a id="dec:member Recalled.PU.int8" href="#def:member Recalled.PU.int8">int8</a><b>:</b> <a href="#def:type Recalled.OpenPU">OpenPU</a><b>&lt;</b><a href="#def:member Recalled.PU.int8">int8</a><b>&gt;</b>
  <b>member</b> <a id="dec:member Recalled.PU.int16" href="#def:member Recalled.PU.int16">int16</a><b>:</b> <a href="#def:type Recalled.OpenPU">OpenPU</a><b>&lt;</b><a href="#def:member Recalled.PU.int16">int16</a><b>&gt;</b>
  <b>member</b> <a id="dec:member Recalled.PU.int32" href="#def:member Recalled.PU.int32">int32</a><b>:</b> <a href="#def:type Recalled.OpenPU">OpenPU</a><b>&lt;</b><a href="#def:member Recalled.PU.int32">int32</a><b>&gt;</b>
  <b>member</b> <a id="dec:member Recalled.PU.int64" href="#def:member Recalled.PU.int64">int64</a><b>:</b> <a href="#def:type Recalled.OpenPU">OpenPU</a><b>&lt;</b><a href="#def:member Recalled.PU.int64">int64</a><b>&gt;</b>
  <b>member</b> <a id="dec:member Recalled.PU.uint8" href="#def:member Recalled.PU.uint8">uint8</a><b>:</b> <a href="#def:type Recalled.OpenPU">OpenPU</a><b>&lt;</b><a href="#def:member Recalled.PU.uint8">uint8</a><b>&gt;</b>
  <b>member</b> <a id="dec:member Recalled.PU.uint16" href="#def:member Recalled.PU.uint16">uint16</a><b>:</b> <a href="#def:type Recalled.OpenPU">OpenPU</a><b>&lt;</b><a href="#def:member Recalled.PU.uint16">uint16</a><b>&gt;</b>
  <b>member</b> <a id="dec:member Recalled.PU.uint32" href="#def:member Recalled.PU.uint32">uint32</a><b>:</b> <a href="#def:type Recalled.OpenPU">OpenPU</a><b>&lt;</b><a href="#def:member Recalled.PU.uint32">uint32</a><b>&gt;</b>
  <b>member</b> <a id="dec:member Recalled.PU.uint64" href="#def:member Recalled.PU.uint64">uint64</a><b>:</b> <a href="#def:type Recalled.OpenPU">OpenPU</a><b>&lt;</b><a href="#def:member Recalled.PU.uint64">uint64</a><b>&gt;</b>
  <b>member</b> <a id="dec:member Recalled.PU.float32" href="#def:member Recalled.PU.float32">float32</a><b>:</b> <a href="#def:type Recalled.OpenPU">OpenPU</a><b>&lt;</b><a href="#def:member Recalled.PU.float32">float32</a><b>&gt;</b>
  <b>member</b> <a id="dec:member Recalled.PU.float64" href="#def:member Recalled.PU.float64">float64</a><b>:</b> <a href="#def:type Recalled.OpenPU">OpenPU</a><b>&lt;</b>float<b>&gt;</b>
  <b>member</b> <a id="dec:member Recalled.PU.char" href="#def:member Recalled.PU.char">char</a><b>:</b> <a href="#def:type Recalled.OpenPU">OpenPU</a><b>&lt;</b><a href="#def:member Recalled.PU.char">char</a><b>&gt;</b>
  <b>member</b> <a id="dec:member Recalled.PU.string" href="#def:member Recalled.PU.string">string</a><b>:</b> <a href="#def:type Recalled.OpenPU">OpenPU</a><b>&lt;</b><a href="#def:member Recalled.PU.string">string</a><b>&gt;</b>
  <b>member</b> <a id="dec:member Recalled.PU.DateTime" href="#def:member Recalled.PU.DateTime">DateTime</a><b>:</b> <a href="#def:type Recalled.OpenPU">OpenPU</a><b>&lt;</b><a href="#def:member Recalled.PU.DateTime">DateTime</a><b>&gt;</b>
  <b>member</b> <a id="dec:member Recalled.PU.Digest" href="#def:member Recalled.PU.Digest">Digest</a><b>:</b> <a href="#def:type Recalled.OpenPU">OpenPU</a><b>&lt;</b>Internal<b>.</b><a href="#def:member Recalled.PU.Digest">Digest</a><b>&gt;</b>
  <b>member</b> <a id="dec:member Recalled.PU.BigInteger" href="#def:member Recalled.PU.BigInteger">BigInteger</a><b>:</b> <a href="#def:type Recalled.OpenPU">OpenPU</a><b>&lt;</b><a href="#def:member Recalled.PU.BigInteger">BigInteger</a><b>&gt;</b>
  <b>member</b> <a id="dec:member Recalled.PU.bytes" href="#def:member Recalled.PU.bytes">bytes</a><b>:</b> <a href="#def:type Recalled.OpenPU">OpenPU</a><b>&lt;</b><a href="#def:member Recalled.PU.array">array</a><b>&lt;</b>byte<b>&gt;&gt;</b>
  <b>member</b> <a id="dec:member Recalled.PU.list" href="#def:member Recalled.PU.list">list</a><b>:</b> <a href="#def:type Recalled.OpenPU">OpenPU</a><b>&lt;</b><i>'t</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Recalled.OpenPU">OpenPU</a><b>&lt;</b><a href="#def:member Recalled.PU.list">list</a><b>&lt;</b><i>'t</i><b>&gt;&gt;</b>
  <b>member</b> <a id="dec:member Recalled.PU.array" href="#def:member Recalled.PU.array">array</a><b>:</b> <a href="#def:type Recalled.OpenPU">OpenPU</a><b>&lt;</b><i>'t</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Recalled.OpenPU">OpenPU</a><b>&lt;</b><a href="#def:member Recalled.PU.array">array</a><b>&lt;</b><i>'t</i><b>&gt;&gt;</b>
  <b>member</b> <a id="dec:member Recalled.PU.case" href="#def:member Recalled.PU.case">case</a><b>:</b> Case<b>&lt;</b>Empty, <i>'cs</i>, <i>'t</i><b>&gt;</b>
         <b>-&gt;</b> <a href="#def:type Recalled.UnionPU">UnionPU</a><b>&lt;</b>Empty, <i>'cs</i>, <i>'t</i><b>&gt;</b>
  <b>member</b> <a id="dec:member Recalled.PU.case" href="#def:member Recalled.PU.case">case</a><b>:</b> Case<b>&lt;</b><i>'ls</i>,      <i>'cs</i>, <i>'t</i><b>&gt;</b>
        <b>*</b> <a href="#def:type Recalled.ProductPU">ProductPU</a><b>&lt;</b><i>'ls</i>, <i>'ls</i>,      <i>'t</i><b>&gt;</b>
         <b>-&gt;</b> <a href="#def:type Recalled.UnionPU">UnionPU</a><b>&lt;</b><i>'ls</i>,      <i>'cs</i>, <i>'t</i><b>&gt;</b>
  <b>member</b> <a id="dec:member Recalled.PU.plus" href="#def:member Recalled.PU.plus">plus</a><b>:</b> <a href="#def:type Recalled.UnionPU">UnionPU</a><b>&lt;</b>       <i>'c</i>      , Choice<b>&lt;</b><i>'c</i>, <i>'cs</i><b>&gt;</b>, <i>'t</i><b>&gt;</b>
             <b>*</b> <a href="#def:type Recalled.UnionPU">UnionPU</a><b>&lt;</b>           <i>'cs</i> ,            <i>'cs</i> , <i>'t</i><b>&gt;</b>
            <b>-&gt;</b> <a href="#def:type Recalled.UnionPU">UnionPU</a><b>&lt;</b>Choice<b>&lt;</b><i>'c</i>, <i>'cs</i><b>&gt;</b>, Choice<b>&lt;</b><i>'c</i>, <i>'cs</i><b>&gt;</b>, <i>'t</i><b>&gt;</b>
  <b>member</b> <a id="dec:member Recalled.PU.union" href="#def:member Recalled.PU.union">union</a><b>:</b> Rep
            <b>*</b> Union<b>&lt;</b>          <i>'t</i><b>&gt;</b>
         <b>*</b> AsChoice<b>&lt;</b><i>'cs</i>,      <i>'t</i><b>&gt;</b>
          <b>*</b> <a href="#def:type Recalled.UnionPU">UnionPU</a><b>&lt;</b><i>'cs</i>, <i>'cs</i>, <i>'t</i><b>&gt;</b>
          <b>-&gt;</b> <a href="#def:type Recalled.OpenPU">OpenPU</a><b>&lt;</b>          <i>'t</i><b>&gt;</b>
  <b>member</b> <a id="dec:member Recalled.PU.elem" href="#def:member Recalled.PU.elem">elem</a><b>:</b> Elem<b>&lt;</b><i>'e</i>, <i>'es</i>, <i>'t</i><b>&gt;</b>
           <b>*</b> <a href="#def:type Recalled.OpenPU">OpenPU</a><b>&lt;</b><i>'e</i>         <b>&gt;</b>
       <b>-&gt;</b> <a href="#def:type Recalled.ProductPU">ProductPU</a><b>&lt;</b><i>'e</i>, <i>'es</i>, <i>'t</i><b>&gt;</b>
  <b>member</b> <a id="dec:member Recalled.PU.times" href="#def:member Recalled.PU.times">times</a><b>:</b> <a href="#def:type Recalled.ProductPU">ProductPU</a><b>&lt;</b>    <i>'e</i>      , And<b>&lt;</b><i>'e</i>, <i>'es</i><b>&gt;</b>, <i>'t</i><b>&gt;</b>
              <b>*</b> <a href="#def:type Recalled.ProductPU">ProductPU</a><b>&lt;</b>        <i>'es</i> ,         <i>'es</i> , <i>'t</i><b>&gt;</b>
             <b>-&gt;</b> <a href="#def:type Recalled.ProductPU">ProductPU</a><b>&lt;</b>And<b>&lt;</b><i>'e</i>, <i>'es</i><b>&gt;</b>, And<b>&lt;</b><i>'e</i>, <i>'es</i><b>&gt;</b>, <i>'t</i><b>&gt;</b>
  <b>member</b> <a id="dec:member Recalled.PU.product" href="#def:member Recalled.PU.product">product</a><b>:</b> Rep
            <b>*</b> Product<b>&lt;</b>          <i>'t</i><b>&gt;</b>
          <b>*</b> AsProduct<b>&lt;</b><i>'es</i>,      <i>'t</i><b>&gt;</b>
          <b>*</b> <a href="#def:type Recalled.ProductPU">ProductPU</a><b>&lt;</b><i>'es</i>, <i>'es</i>, <i>'t</i><b>&gt;</b>
            <b>-&gt;</b> <a href="#def:type Recalled.OpenPU">OpenPU</a><b>&lt;</b>          <i>'t</i><b>&gt;</b>
</pre>
<pre><b>type</b> <a id="dec:type Recalled.Log" href="#def:type Recalled.Log">Log</a>
</pre>
<pre><b>type</b> <a id="dec:type Recalled.Update" href="#def:type Recalled.Update">Update</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<pre><b>type</b> <a id="dec:type Recalled.Logged" href="#def:type Recalled.Logged">Logged</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<pre><b>type</b> <a id="dec:type Recalled.WithLog" href="#def:type Recalled.WithLog">WithLog</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>=</b> Log <b>-&gt;</b> Job<b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<pre><b>type</b> <a id="dec:type Recalled.LogAs" href="#def:type Recalled.LogAs">LogAs</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<pre><b>type</b> <a id="dec:type Recalled.Log" href="#def:type Recalled.Log">Log</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<pre><b>type</b> <a id="dec:type Recalled.UpdateBuilder" href="#def:type Recalled.UpdateBuilder">UpdateBuilder</a>  <b>=</b>
  <b>new</b><b>:</b> unit <b>-&gt;</b> <a href="#def:type Recalled.UpdateBuilder">UpdateBuilder</a>
  <b>member</b> Delay<b>:</b> (unit <b>-&gt;</b> <a href="#def:type Recalled.Update">Update</a><b>&lt;</b><i>'x</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Recalled.Update">Update</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>member</b> Return<b>:</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Recalled.Update">Update</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>member</b> ReturnFrom<b>:</b> <a href="#def:type Recalled.Update">Update</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Recalled.Update">Update</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>member</b> ReturnFrom<b>:</b>  <a href="#def:type Recalled.LogAs">LogAs</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Recalled.Update">Update</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>member</b> ReturnFrom<b>:</b>    Log<b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Recalled.Update">Update</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>member</b> ReturnFrom<b>:</b>    Job<b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Recalled.Update">Update</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>member</b> Bind<b>:</b> <a href="#def:type Recalled.Update">Update</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>*</b> (<i>'x</i> <b>-&gt;</b> <a href="#def:type Recalled.Update">Update</a><b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Recalled.Update">Update</a><b>&lt;</b><i>'y</i><b>&gt;</b>
  <b>member</b> Bind<b>:</b>  <a href="#def:type Recalled.LogAs">LogAs</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>*</b> (<i>'x</i> <b>-&gt;</b> <a href="#def:type Recalled.Update">Update</a><b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Recalled.Update">Update</a><b>&lt;</b><i>'y</i><b>&gt;</b>
  <b>member</b> Bind<b>:</b>    Log<b>&lt;</b><i>'x</i><b>&gt;</b> <b>*</b> (<i>'x</i> <b>-&gt;</b> <a href="#def:type Recalled.Update">Update</a><b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Recalled.Update">Update</a><b>&lt;</b><i>'y</i><b>&gt;</b>
  <b>member</b> Bind<b>:</b>    Job<b>&lt;</b><i>'x</i><b>&gt;</b> <b>*</b> (<i>'x</i> <b>-&gt;</b> <a href="#def:type Recalled.Update">Update</a><b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Recalled.Update">Update</a><b>&lt;</b><i>'y</i><b>&gt;</b>
  <b>member</b> Combine<b>:</b> <a href="#def:type Recalled.Update">Update</a><b>&lt;</b>unit<b>&gt;</b> <b>*</b> <a href="#def:type Recalled.Update">Update</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Recalled.Update">Update</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>member</b> Zero<b>:</b> unit <b>-&gt;</b> <a href="#def:type Recalled.Update">Update</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<pre><b>[&lt;</b>Class<b>&gt;]</b> 
<b>type</b> <a id="dec:type Recalled.LogAsBuilder" href="#def:type Recalled.LogAsBuilder">LogAsBuilder</a>  <b>=</b>
  inherit <a href="#def:type Recalled.UpdateBuilder">UpdateBuilder</a>
  <b>member</b> Run<b>:</b> <a href="#def:type Recalled.Update">Update</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Recalled.LogAs">LogAs</a><b>&lt;</b><a href="#def:type Recalled.Logged">Logged</a><b>&lt;</b><i>'x</i><b>&gt;&gt;</b>
</pre>
<pre><b>[&lt;</b>Class<b>&gt;]</b> 
<b>type</b> <a id="dec:type Recalled.LogBuilder" href="#def:type Recalled.LogBuilder">LogBuilder</a>  <b>=</b>
  inherit <a href="#def:type Recalled.UpdateBuilder">UpdateBuilder</a>
  <b>member</b> Run<b>:</b> <a href="#def:type Recalled.Update">Update</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> Log<b>&lt;</b><a href="#def:type Recalled.Logged">Logged</a><b>&lt;</b><i>'x</i><b>&gt;&gt;</b>
</pre>
<pre><b>type</b> <a id="dec:type Recalled.WithLogBuilder" href="#def:type Recalled.WithLogBuilder">WithLogBuilder</a>  <b>=</b>
  <b>new</b><b>:</b> unit <b>-&gt;</b> <a href="#def:type Recalled.WithLogBuilder">WithLogBuilder</a>
  <b>member</b> Delay<b>:</b> (unit <b>-&gt;</b> <a href="#def:type Recalled.WithLog">WithLog</a><b>&lt;</b><i>'x</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Recalled.WithLog">WithLog</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>member</b> Return<b>:</b> <i>'x</i> <b>-&gt;</b> <a href="#def:type Recalled.WithLog">WithLog</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>member</b> ReturnFrom<b>:</b> <a href="#def:type Recalled.WithLog">WithLog</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Recalled.WithLog">WithLog</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>member</b>        ReturnFrom<b>:</b>   <a href="#def:type Recalled.LogAs">LogAs</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Recalled.WithLog">WithLog</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>member</b> ReturnFrom<b>:</b>     Job<b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Recalled.WithLog">WithLog</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>member</b> Bind<b>:</b> <a href="#def:type Recalled.WithLog">WithLog</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>*</b> (<i>'x</i> <b>-&gt;</b> <a href="#def:type Recalled.WithLog">WithLog</a><b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Recalled.WithLog">WithLog</a><b>&lt;</b><i>'y</i><b>&gt;</b>
  <b>member</b>        Bind<b>:</b>   <a href="#def:type Recalled.LogAs">LogAs</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>*</b> (<i>'x</i> <b>-&gt;</b> <a href="#def:type Recalled.WithLog">WithLog</a><b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Recalled.WithLog">WithLog</a><b>&lt;</b><i>'y</i><b>&gt;</b>
  <b>member</b> Bind<b>:</b>     Job<b>&lt;</b><i>'x</i><b>&gt;</b> <b>*</b> (<i>'x</i> <b>-&gt;</b> <a href="#def:type Recalled.WithLog">WithLog</a><b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Recalled.WithLog">WithLog</a><b>&lt;</b><i>'y</i><b>&gt;</b>
  <b>member</b> Combine<b>:</b> <a href="#def:type Recalled.WithLog">WithLog</a><b>&lt;</b>unit<b>&gt;</b> <b>*</b> <a href="#def:type Recalled.WithLog">WithLog</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Recalled.WithLog">WithLog</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>member</b> TryFinally<b>:</b> <a href="#def:type Recalled.WithLog">WithLog</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>*</b> (unit <b>-&gt;</b> unit) <b>-&gt;</b> <a href="#def:type Recalled.WithLog">WithLog</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>member</b> TryWith<b>:</b> <a href="#def:type Recalled.WithLog">WithLog</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>*</b> (exn <b>-&gt;</b> <a href="#def:type Recalled.WithLog">WithLog</a><b>&lt;</b><i>'x</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Recalled.WithLog">WithLog</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>member</b> Using<b>:</b> <i>'x</i> <b>*</b> (<i>'x</i> <b>-&gt;</b> <a href="#def:type Recalled.WithLog">WithLog</a><b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Recalled.WithLog">WithLog</a><b>&lt;</b><i>'y</i><b>&gt;</b> <b>when</b> <i>'x</i> <b>:&gt;</b> IDisposable
  <b>member</b> For<b>:</b> seq<b>&lt;</b><i>'x</i><b>&gt;</b> <b>*</b> (<i>'x</i> <b>-&gt;</b> <a href="#def:type Recalled.WithLog">WithLog</a><b>&lt;</b>unit<b>&gt;</b>) <b>-&gt;</b> <a href="#def:type Recalled.WithLog">WithLog</a><b>&lt;</b>unit<b>&gt;</b>
  <b>member</b> While<b>:</b> (unit <b>-&gt;</b> <a href="#def:member Recalled.PU.bool">bool</a>) <b>*</b> <a href="#def:type Recalled.WithLog">WithLog</a><b>&lt;</b>unit<b>&gt;</b> <b>-&gt;</b> <a href="#def:type Recalled.WithLog">WithLog</a><b>&lt;</b>unit<b>&gt;</b>
  <b>member</b> Zero<b>:</b> unit <b>-&gt;</b> <a href="#def:type Recalled.WithLog">WithLog</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<pre><b>[&lt;</b>Class<b>&gt;]</b> 
<b>type</b> <a id="dec:type Recalled.RunWithLogBuilder" href="#def:type Recalled.RunWithLogBuilder">RunWithLogBuilder</a>  <b>=</b>
  inherit <a href="#def:type Recalled.WithLogBuilder">WithLogBuilder</a>
  <b>member</b> Run<b>:</b> <a href="#def:type Recalled.WithLog">WithLog</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> Job<b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<pre><b>module</b> <a id="dec:module Recalled.Seq" href="#def:module Recalled.Seq">Seq</a>  <b>=</b>
  <b>val</b> <a id="dec:val Recalled.Seq.mapUpdate" href="#def:val Recalled.Seq.mapUpdate">mapUpdate</a><b>:</b> (<i>'x</i> <b>-&gt;</b> <a href="#def:type Recalled.Update">Update</a><b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> seq<b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Recalled.Update">Update</a><b>&lt;</b>ResizeArray<b>&lt;</b><i>'y</i><b>&gt;&gt;</b>
  <b>val</b> <a id="dec:val Recalled.Seq.mapLogAs" href="#def:val Recalled.Seq.mapLogAs">mapLogAs</a><b>:</b> (<i>'x</i> <b>-&gt;</b> <a href="#def:type Recalled.LogAs">LogAs</a><b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> seq<b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Recalled.Update">Update</a><b>&lt;</b>ResizeArray<b>&lt;</b><i>'y</i><b>&gt;&gt;</b>
</pre>
<pre><b>[&lt;</b>AutoOpen<b>&gt;]</b>
<b>module</b> <a id="dec:module Recalled.Recalled" href="#def:module Recalled.Recalled">Recalled</a>  <b>=</b>
  <b>val</b> <a id="dec:val Recalled.Recalled.recall" href="#def:val Recalled.Recalled.recall">recall</a><b>:</b> logDir<b>:</b> <a href="#def:member Recalled.PU.string">string</a> <b>-&gt;</b> <a href="#def:type Recalled.RunWithLogBuilder">RunWithLogBuilder</a>
  <b>val</b> <a id="dec:val Recalled.Recalled.logged" href="#def:val Recalled.Recalled.logged">logged</a><b>:</b> <a href="#def:type Recalled.WithLogBuilder">WithLogBuilder</a>
  <b>val</b> <a id="dec:val Recalled.Recalled.logAs" href="#def:val Recalled.Recalled.logAs">logAs</a><b>:</b> id<b>:</b> <a href="#def:member Recalled.PU.string">string</a> <b>-&gt;</b> <a href="#def:type Recalled.LogAsBuilder">LogAsBuilder</a>
  <b>val</b> <a id="dec:val Recalled.Recalled.log" href="#def:val Recalled.Recalled.log">log</a><b>:</b> <a href="#def:type Recalled.LogBuilder">LogBuilder</a>
  <b>val</b> <a id="dec:val Recalled.Recalled.watch" href="#def:val Recalled.Recalled.watch">watch</a><b>:</b> <i>'x</i> <b>-&gt;</b> Log<b>&lt;</b>unit<b>&gt;</b>
  <b>val</b> <a id="dec:val Recalled.Recalled.update" href="#def:val Recalled.Recalled.update">update</a><b>:</b> <a href="#def:type Recalled.UpdateBuilder">UpdateBuilder</a>
  <b>val</b> <a id="dec:val Recalled.Recalled.digest" href="#def:val Recalled.Recalled.digest">digest</a><b>:</b> <a href="#def:type Recalled.Update">Update</a><b>&lt;</b>Internal<b>.</b><a href="#def:member Recalled.PU.Digest">Digest</a><b>&gt;</b>
  <b>val</b> <a id="dec:val Recalled.Recalled.read" href="#def:val Recalled.Recalled.read">read</a><b>:</b> <a href="#def:type Recalled.Logged">Logged</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Recalled.Update">Update</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Recalled.Recalled.wait" href="#def:val Recalled.Recalled.wait">wait</a><b>:</b> <a href="#def:type Recalled.LogAs">LogAs</a><b>&lt;</b><a href="#def:type Recalled.Logged">Logged</a><b>&lt;</b><i>'x</i><b>&gt;&gt;</b> <b>-&gt;</b> <a href="#def:type Recalled.LogAs">LogAs</a><b>&lt;</b><i>'x</i><b>&gt;</b>
  <b>val</b> <a id="dec:val Recalled.Recalled.getCancelAlt" href="#def:val Recalled.Recalled.getCancelAlt">getCancelAlt</a><b>:</b> <a href="#def:type Recalled.WithLog">WithLog</a><b>&lt;</b>Alt<b>&lt;</b>unit<b>&gt;&gt;</b>
</pre>
<h2>Description</h2>
<pre><b>namespace</b> <a id="def:namespace Recalled" href="#dec:namespace Recalled">Recalled</a>
</pre>
<div class="nested"><p> Recalled is a library for defining persistent, incremental, parallel computations such as build systems.  The main goals for Recalled are to make it straightforward to define such computations and to scale such computations.</p><p> The central concept of Recalled is that of a logged computation, represented by the <code><a href="#def:type Recalled.Logged">Logged</a><b>&lt;</b><i>'x</i><b>&gt;</b></code> type constructor.  A logged computation is defined and executed in such a manner that after it has been run to completion, the computation can be recreated, possibly in a separate run of the program, and its result can be recovered without actually running the recreated computation to completion, assuming Recalled finds nothing that has changed that could change the result of the computation.</p><p> A correctly defined logged computation is recomputed by Recalled if it needs to be recomputed, because its result may have changed.  Recalled makes it easy for the programmer to write correct logged computations, but does not strictly enforce correctness.  Strictly enforcing correctness is essentially impossible to do in a impure language in a convenient manner, because it precludes the use of built-in lambda expressions.  Therefore Recalled chooses convenience over cumbersomeness.  To define a correct logged computation, the programmer simply needs to make sure that any input that may change the output of a computation is essentially seen by Recalled.</p><p> Logged computations are defined and executed using lightweight threads, called jobs, provided by the Hopac library.  This directly allows logged computations to scale to multiple cores to exploit parallelism.  The use of lightweight threads also allows a logged computation to perform long latency operations, e.g. to perform distributed operations over a network of machines or to perform other forms of asynchronous IO, while allowing full use of the cores of the local machine to process other computations.<pre><b>[&lt;</b>AbstractClass<b>&gt;]</b> 
<b>type</b> <a id="def:type Recalled.PU" href="#dec:type Recalled.PU">PU</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>=</b>
</pre>
<div class="nested"><p> Represents a capability to serialize values of type <code><i>'x</i></code>.</p><p> This class has a very low level interface and is designed to make it possible to implement nearly optimal serialization to and deserialization from memory mapped files.  This is important, because Recalled serializes all the results of logged computations and potentially deserializes large numbers of those results.</p><p> In most cases client code should not need to implement this class directly as the <code>PU</code> class provides inference rules to generate instances of this class for a wide variety of F# types.<pre><b>new</b><b>:</b> unit <b>-&gt;</b> PU<b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Empty default constructor.</div>
<pre><b>abstract</b> <a id="def:abstract Recalled.PU.Size" href="#dec:abstract Recalled.PU.Size">Size</a><b>:</b> <i>'x</i> <b>-&gt;</b> int
</pre>
<div class="nested"><p> Compute the serialized size of the given value.</div>
<pre><b>abstract</b> <a id="def:abstract Recalled.PU.Dopickle" href="#dec:abstract Recalled.PU.Dopickle">Dopickle</a><b>:</b> <i>'x</i> <b>*</b> nativeptr<b>&lt;</b>byte<b>&gt;</b> <b>-&gt;</b> unit
</pre>
<div class="nested"><p> Conditionally serialize given value to memory starting at the specified address.</p><p> The caller is responsible for ensuring that the pointer points to a region of memory that has at least the number of bytes of space as returned by <code><a href="#def:abstract Recalled.PU.Size">Size</a></code>.  The <code>DoPickle</code> implementation must not write to memory outside of that range.</p><p> Memory at the specified address should be first read and only written to if it differs from the value being written.  This allows the space for a previous value of the same type and size to be reused and, at the same time, make sure that persistent storage is only written to when the stored value is different.</div>
<pre><b>abstract</b> <a id="def:abstract Recalled.PU.Unpickle" href="#dec:abstract Recalled.PU.Unpickle">Unpickle</a><b>:</b> nativeptr<b>&lt;</b>byte<b>&gt;</b> <b>-&gt;</b> <i>'x</i>
</pre>
<div class="nested"><p> Deserialize value from memory starting at the specified address.</div>
</div>
<pre><b>type</b> <a id="def:type Recalled.OpenPU" href="#dec:type Recalled.OpenPU">OpenPU</a><b>&lt;</b><i>'t</i><b>&gt;</b>
</pre>
<div class="nested"><p> Represents a capability to serialize values of type <code><i>'t</i></code> and is open to be combined and extended.</div>
<pre><b>type</b> <a id="def:type Recalled.ProductPU" href="#dec:type Recalled.ProductPU">ProductPU</a><b>&lt;</b><i>'e</i>, <i>'es</i>, <i>'t</i><b>&gt;</b>
</pre>
<div class="nested"><p> Represents a capability to serialize a part of a product type.</div>
<pre><b>type</b> <a id="def:type Recalled.UnionPU" href="#dec:type Recalled.UnionPU">UnionPU</a><b>&lt;</b><i>'c</i>, <i>'cs</i>, <i>'t</i><b>&gt;</b>
</pre>
<div class="nested"><p> Represents a capability to serialize a subset of a union type.</div>
<pre><b>[&lt;</b>InferenceRules<b>&gt;]</b> 
<b>type</b> <a id="def:type Recalled.PU" href="#dec:type Recalled.PU">PU</a>  <b>=</b>
</pre>
<div class="nested"><p> Provides inference rules for a datatype generic serialization capability.</p><p> The methods of this class aside from <code><a href="#def:static member Recalled.PU.Get">Get</a></code> are ordinarily not called directly by client code, but are rather called indirectly by <code><a href="#def:static member Recalled.PU.Get">Get</a></code> to construct the desired serialization capability.</p><p> Please note that the method signatures can be seen as a specification of which types are supported by the inference rules.<pre><b>static</b> <b>member</b> <a id="def:static member Recalled.PU.Get" href="#dec:static member Recalled.PU.Get">Get</a><b>:</b> unit <b>-&gt;</b> PU<b>&lt;</b><i>'t</i><b>&gt;</b>
</pre>
<div class="nested"><p> Returns a previously generated serialization capability or attempts to generate one for the specified type <code><i>'t</i></code>.</div>
<pre><b>new</b><b>:</b> unit <b>-&gt;</b> PU
</pre>
<div class="nested"><p> Empty default constructor.</div>
<pre><b>member</b> <a id="def:member Recalled.PU.toPU" href="#dec:member Recalled.PU.toPU">toPU</a><b>:</b> <a href="#def:type Recalled.OpenPU">OpenPU</a><b>&lt;</b><i>'t</i><b>&gt;</b> <b>-&gt;</b> PU<b>&lt;</b><i>'t</i><b>&gt;</b>
</pre>
<div class="nested"><p> Completes the serialization capability for a serializable type.</div>
<pre><b>member</b> <a id="def:member Recalled.PU.fix" href="#dec:member Recalled.PU.fix">fix</a><b>:</b> unit <b>-&gt;</b> Rec<b>&lt;</b><a href="#def:type Recalled.OpenPU">OpenPU</a><b>&lt;</b><i>'t</i><b>&gt;&gt;</b>
</pre>
<div class="nested"><p> Capability to compute serialization capabilities for recursive types.</div>
<pre><b>member</b> <a id="def:member Recalled.PU.unit" href="#dec:member Recalled.PU.unit">unit</a><b>:</b> <a href="#def:type Recalled.OpenPU">OpenPU</a><b>&lt;</b>unit<b>&gt;</b>
</pre>
<div class="nested"><p> Serialization capability for the <code>unit</code> type.</div>
<pre><b>member</b> <a id="def:member Recalled.PU.bool" href="#dec:member Recalled.PU.bool">bool</a><b>:</b> <a href="#def:type Recalled.OpenPU">OpenPU</a><b>&lt;</b><a href="#def:member Recalled.PU.bool">bool</a><b>&gt;</b>
</pre>
<div class="nested"><p> Serialization capability for the <code><a href="#def:member Recalled.PU.bool">bool</a></code> type.</div>
<pre><b>member</b> <a id="def:member Recalled.PU.int8" href="#dec:member Recalled.PU.int8">int8</a><b>:</b> <a href="#def:type Recalled.OpenPU">OpenPU</a><b>&lt;</b><a href="#def:member Recalled.PU.int8">int8</a><b>&gt;</b>
</pre>
<div class="nested"><p> Serialization capability for the <code><a href="#def:member Recalled.PU.int8">int8</a></code> type.</div>
<pre><b>member</b> <a id="def:member Recalled.PU.int16" href="#dec:member Recalled.PU.int16">int16</a><b>:</b> <a href="#def:type Recalled.OpenPU">OpenPU</a><b>&lt;</b><a href="#def:member Recalled.PU.int16">int16</a><b>&gt;</b>
</pre>
<div class="nested"><p> Serialization capability for the <code><a href="#def:member Recalled.PU.int16">int16</a></code> type.</div>
<pre><b>member</b> <a id="def:member Recalled.PU.int32" href="#dec:member Recalled.PU.int32">int32</a><b>:</b> <a href="#def:type Recalled.OpenPU">OpenPU</a><b>&lt;</b><a href="#def:member Recalled.PU.int32">int32</a><b>&gt;</b>
</pre>
<div class="nested"><p> Serialization capability for the <code><a href="#def:member Recalled.PU.int32">int32</a></code> type.</div>
<pre><b>member</b> <a id="def:member Recalled.PU.int64" href="#dec:member Recalled.PU.int64">int64</a><b>:</b> <a href="#def:type Recalled.OpenPU">OpenPU</a><b>&lt;</b><a href="#def:member Recalled.PU.int64">int64</a><b>&gt;</b>
</pre>
<div class="nested"><p> Serialization capability for the <code><a href="#def:member Recalled.PU.int64">int64</a></code> type.</div>
<pre><b>member</b> <a id="def:member Recalled.PU.uint8" href="#dec:member Recalled.PU.uint8">uint8</a><b>:</b> <a href="#def:type Recalled.OpenPU">OpenPU</a><b>&lt;</b><a href="#def:member Recalled.PU.uint8">uint8</a><b>&gt;</b>
</pre>
<div class="nested"><p> Serialization capability for the <code><a href="#def:member Recalled.PU.uint8">uint8</a></code> type.</div>
<pre><b>member</b> <a id="def:member Recalled.PU.uint16" href="#dec:member Recalled.PU.uint16">uint16</a><b>:</b> <a href="#def:type Recalled.OpenPU">OpenPU</a><b>&lt;</b><a href="#def:member Recalled.PU.uint16">uint16</a><b>&gt;</b>
</pre>
<div class="nested"><p> Serialization capability for the <code><a href="#def:member Recalled.PU.uint16">uint16</a></code> type.</div>
<pre><b>member</b> <a id="def:member Recalled.PU.uint32" href="#dec:member Recalled.PU.uint32">uint32</a><b>:</b> <a href="#def:type Recalled.OpenPU">OpenPU</a><b>&lt;</b><a href="#def:member Recalled.PU.uint32">uint32</a><b>&gt;</b>
</pre>
<div class="nested"><p> Serialization capability for the <code><a href="#def:member Recalled.PU.uint32">uint32</a></code> type.</div>
<pre><b>member</b> <a id="def:member Recalled.PU.uint64" href="#dec:member Recalled.PU.uint64">uint64</a><b>:</b> <a href="#def:type Recalled.OpenPU">OpenPU</a><b>&lt;</b><a href="#def:member Recalled.PU.uint64">uint64</a><b>&gt;</b>
</pre>
<div class="nested"><p> Serialization capability for the <code><a href="#def:member Recalled.PU.uint64">uint64</a></code> type.</div>
<pre><b>member</b> <a id="def:member Recalled.PU.float32" href="#dec:member Recalled.PU.float32">float32</a><b>:</b> <a href="#def:type Recalled.OpenPU">OpenPU</a><b>&lt;</b><a href="#def:member Recalled.PU.float32">float32</a><b>&gt;</b>
</pre>
<div class="nested"><p> Serialization capability for the <code><a href="#def:member Recalled.PU.float32">float32</a></code> type.</div>
<pre><b>member</b> <a id="def:member Recalled.PU.float64" href="#dec:member Recalled.PU.float64">float64</a><b>:</b> <a href="#def:type Recalled.OpenPU">OpenPU</a><b>&lt;</b>float<b>&gt;</b>
</pre>
<div class="nested"><p> Serialization capability for the <code>float</code> type.</div>
<pre><b>member</b> <a id="def:member Recalled.PU.char" href="#dec:member Recalled.PU.char">char</a><b>:</b> <a href="#def:type Recalled.OpenPU">OpenPU</a><b>&lt;</b><a href="#def:member Recalled.PU.char">char</a><b>&gt;</b>
</pre>
<div class="nested"><p> Serialization capability for the <code><a href="#def:member Recalled.PU.char">char</a></code> type.</div>
<pre><b>member</b> <a id="def:member Recalled.PU.string" href="#dec:member Recalled.PU.string">string</a><b>:</b> <a href="#def:type Recalled.OpenPU">OpenPU</a><b>&lt;</b><a href="#def:member Recalled.PU.string">string</a><b>&gt;</b>
</pre>
<div class="nested"><p> Serialization capability for the <code><a href="#def:member Recalled.PU.string">string</a></code> type.</div>
<pre><b>member</b> <a id="def:member Recalled.PU.DateTime" href="#dec:member Recalled.PU.DateTime">DateTime</a><b>:</b> <a href="#def:type Recalled.OpenPU">OpenPU</a><b>&lt;</b><a href="#def:member Recalled.PU.DateTime">DateTime</a><b>&gt;</b>
</pre>
<div class="nested"><p> Serialization capability for the <code><a href="#def:member Recalled.PU.DateTime">DateTime</a></code> type.</div>
<pre><b>member</b> <a id="def:member Recalled.PU.Digest" href="#dec:member Recalled.PU.Digest">Digest</a><b>:</b> <a href="#def:type Recalled.OpenPU">OpenPU</a><b>&lt;</b>Internal<b>.</b><a href="#def:member Recalled.PU.Digest">Digest</a><b>&gt;</b>
</pre>
<div class="nested"><p> Serialization capability for the <code><a href="#def:member Recalled.PU.Digest">Digest</a></code> type.</div>
<pre><b>member</b> <a id="def:member Recalled.PU.BigInteger" href="#dec:member Recalled.PU.BigInteger">BigInteger</a><b>:</b> <a href="#def:type Recalled.OpenPU">OpenPU</a><b>&lt;</b><a href="#def:member Recalled.PU.BigInteger">BigInteger</a><b>&gt;</b>
</pre>
<div class="nested"><p> Serialization capability for the <code><a href="#def:member Recalled.PU.BigInteger">BigInteger</a></code> type.</div>
<pre><b>member</b> <a id="def:member Recalled.PU.bytes" href="#dec:member Recalled.PU.bytes">bytes</a><b>:</b> <a href="#def:type Recalled.OpenPU">OpenPU</a><b>&lt;</b><a href="#def:member Recalled.PU.array">array</a><b>&lt;</b>byte<b>&gt;&gt;</b>
</pre>
<div class="nested"><p> Serialization capability for the <code><a href="#def:member Recalled.PU.array">array</a><b>&lt;</b>byte<b>&gt;</b></code> type.  Unlike the general <code><a href="#def:member Recalled.PU.array">array</a></code> rule, this version is optimized for arrays of bytes.</div>
<pre><b>member</b> <a id="def:member Recalled.PU.list" href="#dec:member Recalled.PU.list">list</a><b>:</b> <a href="#def:type Recalled.OpenPU">OpenPU</a><b>&lt;</b><i>'t</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Recalled.OpenPU">OpenPU</a><b>&lt;</b><a href="#def:member Recalled.PU.list">list</a><b>&lt;</b><i>'t</i><b>&gt;&gt;</b>
</pre>
<div class="nested"><p> Serialization capability for lists of serializable values.  Unlike the general rules for arbitrary union types, this version treats the list as a sequence of elements and is typically more efficient.</div>
<pre><b>member</b> <a id="def:member Recalled.PU.array" href="#dec:member Recalled.PU.array">array</a><b>:</b> <a href="#def:type Recalled.OpenPU">OpenPU</a><b>&lt;</b><i>'t</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Recalled.OpenPU">OpenPU</a><b>&lt;</b><a href="#def:member Recalled.PU.array">array</a><b>&lt;</b><i>'t</i><b>&gt;&gt;</b>
</pre>
<div class="nested"><p> Serialization capabability for arrays of serializable values.</div>
<pre><b>member</b> <a id="def:member Recalled.PU.case" href="#dec:member Recalled.PU.case">case</a><b>:</b> Case<b>&lt;</b>Empty, <i>'cs</i>, <i>'t</i><b>&gt;</b>
       <b>-&gt;</b> <a href="#def:type Recalled.UnionPU">UnionPU</a><b>&lt;</b>Empty, <i>'cs</i>, <i>'t</i><b>&gt;</b>
</pre>
<div class="nested"><p> Serialization capability for an empty case of a union type.</div>
<pre><b>member</b> <a id="def:member Recalled.PU.case" href="#dec:member Recalled.PU.case">case</a><b>:</b> Case<b>&lt;</b><i>'ls</i>,      <i>'cs</i>, <i>'t</i><b>&gt;</b>
      <b>*</b> <a href="#def:type Recalled.ProductPU">ProductPU</a><b>&lt;</b><i>'ls</i>, <i>'ls</i>,      <i>'t</i><b>&gt;</b>
       <b>-&gt;</b> <a href="#def:type Recalled.UnionPU">UnionPU</a><b>&lt;</b><i>'ls</i>,      <i>'cs</i>, <i>'t</i><b>&gt;</b>
</pre>
<div class="nested"><p> Serialization capability for a non-empty case of a union type.</div>
<pre><b>member</b> <a id="def:member Recalled.PU.plus" href="#dec:member Recalled.PU.plus">plus</a><b>:</b> <a href="#def:type Recalled.UnionPU">UnionPU</a><b>&lt;</b>       <i>'c</i>      , Choice<b>&lt;</b><i>'c</i>, <i>'cs</i><b>&gt;</b>, <i>'t</i><b>&gt;</b>
           <b>*</b> <a href="#def:type Recalled.UnionPU">UnionPU</a><b>&lt;</b>           <i>'cs</i> ,            <i>'cs</i> , <i>'t</i><b>&gt;</b>
          <b>-&gt;</b> <a href="#def:type Recalled.UnionPU">UnionPU</a><b>&lt;</b>Choice<b>&lt;</b><i>'c</i>, <i>'cs</i><b>&gt;</b>, Choice<b>&lt;</b><i>'c</i>, <i>'cs</i><b>&gt;</b>, <i>'t</i><b>&gt;</b>
</pre>
<div class="nested"><p> Serialization capability for multiple cases of a union type.</div>
<pre><b>member</b> <a id="def:member Recalled.PU.union" href="#dec:member Recalled.PU.union">union</a><b>:</b> Rep
          <b>*</b> Union<b>&lt;</b>          <i>'t</i><b>&gt;</b>
       <b>*</b> AsChoice<b>&lt;</b><i>'cs</i>,      <i>'t</i><b>&gt;</b>
        <b>*</b> <a href="#def:type Recalled.UnionPU">UnionPU</a><b>&lt;</b><i>'cs</i>, <i>'cs</i>, <i>'t</i><b>&gt;</b>
        <b>-&gt;</b> <a href="#def:type Recalled.OpenPU">OpenPU</a><b>&lt;</b>          <i>'t</i><b>&gt;</b>
</pre>
<div class="nested"><p> Serialization capability for an arbitrary union type.</div>
<pre><b>member</b> <a id="def:member Recalled.PU.elem" href="#dec:member Recalled.PU.elem">elem</a><b>:</b> Elem<b>&lt;</b><i>'e</i>, <i>'es</i>, <i>'t</i><b>&gt;</b>
         <b>*</b> <a href="#def:type Recalled.OpenPU">OpenPU</a><b>&lt;</b><i>'e</i>         <b>&gt;</b>
     <b>-&gt;</b> <a href="#def:type Recalled.ProductPU">ProductPU</a><b>&lt;</b><i>'e</i>, <i>'es</i>, <i>'t</i><b>&gt;</b>
</pre>
<div class="nested"><p> Serialization capability for an element of a product type.</div>
<pre><b>member</b> <a id="def:member Recalled.PU.times" href="#dec:member Recalled.PU.times">times</a><b>:</b> <a href="#def:type Recalled.ProductPU">ProductPU</a><b>&lt;</b>    <i>'e</i>      , And<b>&lt;</b><i>'e</i>, <i>'es</i><b>&gt;</b>, <i>'t</i><b>&gt;</b>
            <b>*</b> <a href="#def:type Recalled.ProductPU">ProductPU</a><b>&lt;</b>        <i>'es</i> ,         <i>'es</i> , <i>'t</i><b>&gt;</b>
           <b>-&gt;</b> <a href="#def:type Recalled.ProductPU">ProductPU</a><b>&lt;</b>And<b>&lt;</b><i>'e</i>, <i>'es</i><b>&gt;</b>, And<b>&lt;</b><i>'e</i>, <i>'es</i><b>&gt;</b>, <i>'t</i><b>&gt;</b>
</pre>
<div class="nested"><p> Serialization capability for multiple elements of a product type.</div>
<pre><b>member</b> <a id="def:member Recalled.PU.product" href="#dec:member Recalled.PU.product">product</a><b>:</b> Rep
          <b>*</b> Product<b>&lt;</b>          <i>'t</i><b>&gt;</b>
        <b>*</b> AsProduct<b>&lt;</b><i>'es</i>,      <i>'t</i><b>&gt;</b>
        <b>*</b> <a href="#def:type Recalled.ProductPU">ProductPU</a><b>&lt;</b><i>'es</i>, <i>'es</i>, <i>'t</i><b>&gt;</b>
          <b>-&gt;</b> <a href="#def:type Recalled.OpenPU">OpenPU</a><b>&lt;</b>          <i>'t</i><b>&gt;</b>
</pre>
<div class="nested"><p> Serialization capability for an arbitrary product type.</div>
</div>
<pre><b>type</b> <a id="def:type Recalled.Log" href="#dec:type Recalled.Log">Log</a>
</pre>
<div class="nested"><p> Represents a persistent storage.</div>
<pre><b>type</b> <a id="def:type Recalled.Update" href="#dec:type Recalled.Update">Update</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Represents a single primitive step or a sequence of steps of a possibly logged computation.</div>
<pre><b>type</b> <a id="def:type Recalled.Logged" href="#dec:type Recalled.Logged">Logged</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Represents a logged computation.</p><p> During a logged computation, binding the value of another logged computation makes the current logged computation dependent on the result of the bound logged computation.  This way Recalled learns about the input that may change the output of a computation.</div>
<pre><b>type</b> <a id="def:type Recalled.WithLog" href="#dec:type Recalled.WithLog">WithLog</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>=</b> Log <b>-&gt;</b> Job<b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Represents a parallel computation with a log.</div>
<pre><b>type</b> <a id="def:type Recalled.LogAs" href="#dec:type Recalled.LogAs">LogAs</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Represents a computation whose result is logged with a user defined identity.</div>
<pre><b>type</b> <a id="def:type Recalled.Log" href="#dec:type Recalled.Log">Log</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Represents a computation whose result is logged and is given an implicitly created identity based on identity of the surrounding computation.</div>
<pre><b>type</b> <a id="def:type Recalled.UpdateBuilder" href="#dec:type Recalled.UpdateBuilder">UpdateBuilder</a>  <b>=</b>
</pre>
<div class="nested"><p> Builder for steppable computations.</p><p> Note that steppable computations allow only a limited set of computational patterns, because a steppable computation is not guaranteed to be run to completion.  Specifically, while a single step of a computation is guaranteed to be run to completion after it has been started, a sequence of steps is not guaranteed to be run to completion.  Because of this, constructs such as <code><b>use</b></code> cannot be given meaningful semantics.  However, within a single step, even one defined as a job, such constructs can be used.</div>
<pre><b>[&lt;</b>Class<b>&gt;]</b> 
<b>type</b> <a id="def:type Recalled.LogAsBuilder" href="#dec:type Recalled.LogAsBuilder">LogAsBuilder</a>  <b>=</b>
</pre>
<div class="nested"><p> Builder for a computation logged with a user defined identity.</div>
<pre><b>[&lt;</b>Class<b>&gt;]</b> 
<b>type</b> <a id="def:type Recalled.LogBuilder" href="#dec:type Recalled.LogBuilder">LogBuilder</a>  <b>=</b>
</pre>
<div class="nested"><p> Builder for a computation logged with an implicitly assigned identity.</div>
<pre><b>type</b> <a id="def:type Recalled.WithLogBuilder" href="#dec:type Recalled.WithLogBuilder">WithLogBuilder</a>  <b>=</b>
</pre>
<div class="nested"><p> Builder for parallel computations with a log.  A computation with a log is executed in a context with a log for logging individual logged computations.</div>
<pre><b>[&lt;</b>Class<b>&gt;]</b> 
<b>type</b> <a id="def:type Recalled.RunWithLogBuilder" href="#dec:type Recalled.RunWithLogBuilder">RunWithLogBuilder</a>  <b>=</b>
</pre>
<div class="nested"><p> Builder for running a parallel computations with a log.</div>
<pre><b>module</b> <a id="def:module Recalled.Seq" href="#dec:module Recalled.Seq">Seq</a>  <b>=</b>
</pre>
<div class="nested"><p> Additional operations for sequences.<pre><b>val</b> <a id="def:val Recalled.Seq.mapUpdate" href="#dec:val Recalled.Seq.mapUpdate">mapUpdate</a><b>:</b> (<i>'x</i> <b>-&gt;</b> <a href="#def:type Recalled.Update">Update</a><b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> seq<b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Recalled.Update">Update</a><b>&lt;</b>ResizeArray<b>&lt;</b><i>'y</i><b>&gt;&gt;</b>
</pre>
<div class="nested"><p> Creates an update that maps a given update operation over a sequence and returns a new sequence with the results.</div>
<pre><b>val</b> <a id="def:val Recalled.Seq.mapLogAs" href="#dec:val Recalled.Seq.mapLogAs">mapLogAs</a><b>:</b> (<i>'x</i> <b>-&gt;</b> <a href="#def:type Recalled.LogAs">LogAs</a><b>&lt;</b><i>'y</i><b>&gt;</b>) <b>-&gt;</b> seq<b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Recalled.Update">Update</a><b>&lt;</b>ResizeArray<b>&lt;</b><i>'y</i><b>&gt;&gt;</b>
</pre>
<div class="nested"><p> Creates an update that maps a given logged operation over a sequence and returns a new sequence with the results.</div>
</div>
<pre><b>[&lt;</b>AutoOpen<b>&gt;]</b>
<b>module</b> <a id="def:module Recalled.Recalled" href="#dec:module Recalled.Recalled">Recalled</a>  <b>=</b>
</pre>
<div class="nested"><p> Operations for defining computations that can be Recalled.<pre><b>val</b> <a id="def:val Recalled.Recalled.recall" href="#dec:val Recalled.Recalled.recall">recall</a><b>:</b> logDir<b>:</b> <a href="#def:member Recalled.PU.string">string</a> <b>-&gt;</b> <a href="#def:type Recalled.RunWithLogBuilder">RunWithLogBuilder</a>
</pre>
<div class="nested"><p> Creates a job that creates a new or reads an existing computation log stored in the specified directory, creates and runs the given update computation and then waits until all the logged computations have either finished successfully or some computations have failed and the rest have been canceled.  In case all computations finished successfully, the result value is produced.  Otherwise an exception is raised with details on the failed computations.</div>
<pre><b>val</b> <a id="def:val Recalled.Recalled.logged" href="#dec:val Recalled.Recalled.logged">logged</a><b>:</b> <a href="#def:type Recalled.WithLogBuilder">WithLogBuilder</a>
</pre>
<div class="nested"><p> A builder for parallel computations with a log.</div>
<pre><b>val</b> <a id="def:val Recalled.Recalled.logAs" href="#dec:val Recalled.Recalled.logAs">logAs</a><b>:</b> id<b>:</b> <a href="#def:member Recalled.PU.string">string</a> <b>-&gt;</b> <a href="#def:type Recalled.LogAsBuilder">LogAsBuilder</a>
</pre>
<div class="nested"><p> Returns a builder for creating a new logged computation with the given identity.  Computations with the same identity are assumed to be the same computations.  The result of the computation is persisted to a computation log along with dependencies to other logged computations.</p><p> The first time a logged computations is created, it is always run to completion.  When a logged computation with the same identity is recreated it may or may not be run to completion.</p><p> In case the log indicates that the recreated computation has no dependencies to other logged computations then the computation is run to completion every time it is recreated.  This makes it convenient to essentially create new primitive operations and is also quite logical as a computation that has no inputs must either be a constant or it must use some hidden effects to compute its output.</p><p> If, however, the log has a non empty sequence of dependencies to other logged computations, then the recreated computation is run to completion only if the sequence of dependencies changes or the result of any one of those logged computations has changed.  This works correctly as long as any input that may change the result of the computation are bound as other logged computations within the defined logged computation.</div>
<pre><b>val</b> <a id="def:val Recalled.Recalled.log" href="#dec:val Recalled.Recalled.log">log</a><b>:</b> <a href="#def:type Recalled.LogBuilder">LogBuilder</a>
</pre>
<div class="nested"><p> Returns a builder for creating a new logged computation.  The computation is given an automatically determined identity.</div>
<pre><b>val</b> <a id="def:val Recalled.Recalled.watch" href="#dec:val Recalled.Recalled.watch">watch</a><b>:</b> <i>'x</i> <b>-&gt;</b> Log<b>&lt;</b>unit<b>&gt;</b>
</pre>
<div class="nested"><p> Returns a computation that logs the given value as a dependency.</div>
<pre><b>val</b> <a id="def:val Recalled.Recalled.update" href="#dec:val Recalled.Recalled.update">update</a><b>:</b> <a href="#def:type Recalled.UpdateBuilder">UpdateBuilder</a>
</pre>
<div class="nested"><p> A builder for defining updates or partial logged computations whose results are not logged.</div>
<pre><b>val</b> <a id="def:val Recalled.Recalled.digest" href="#dec:val Recalled.Recalled.digest">digest</a><b>:</b> <a href="#def:type Recalled.Update">Update</a><b>&lt;</b>Internal<b>.</b><a href="#def:member Recalled.PU.Digest">Digest</a><b>&gt;</b>
</pre>
<div class="nested"><p> Provides an intermediate digest of the current point in a logged computation.</p><p> The intermediate digest includes the identity of the current computation as well as digests of the results of all the dependencies of the current computation.  If you ask the intermediate digest after logging all dependencies and just before computing the result of the current logged computation, then the intermediate digest effectively identifies the result.  You could, for example, then use the digest to request a previously computed result from a server.</div>
<pre><b>val</b> <a id="def:val Recalled.Recalled.read" href="#dec:val Recalled.Recalled.read">read</a><b>:</b> <a href="#def:type Recalled.Logged">Logged</a><b>&lt;</b><i>'x</i><b>&gt;</b> <b>-&gt;</b> <a href="#def:type Recalled.Update">Update</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Returns an operation with a log that waits for the result of the logged operation.</div>
<pre><b>val</b> <a id="def:val Recalled.Recalled.wait" href="#dec:val Recalled.Recalled.wait">wait</a><b>:</b> <a href="#def:type Recalled.LogAs">LogAs</a><b>&lt;</b><a href="#def:type Recalled.Logged">Logged</a><b>&lt;</b><i>'x</i><b>&gt;&gt;</b> <b>-&gt;</b> <a href="#def:type Recalled.LogAs">LogAs</a><b>&lt;</b><i>'x</i><b>&gt;</b>
</pre>
<div class="nested"><p> Returns an operation with a log that directly waits for the result of the logged operation.</div>
<pre><b>val</b> <a id="def:val Recalled.Recalled.getCancelAlt" href="#dec:val Recalled.Recalled.getCancelAlt">getCancelAlt</a><b>:</b> <a href="#def:type Recalled.WithLog">WithLog</a><b>&lt;</b>Alt<b>&lt;</b>unit<b>&gt;&gt;</b>
</pre>
<div class="nested"><p> Provides an alternative that becomes enabled if some computation within the whole logged computation has failed.  This allows long running computation steps to cancel themselves cleanly without having to wait until the completion of the step.</p><p> Note that Recalled automatically cancels computations in case of failure. Explicit cancellation is unlikely to provide any benefits except in case of computations that perform long running embedded asynchronous operations.</div>
</div>
</div>
</td></tr></table></body>
</html>
